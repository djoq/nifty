{"ast":null,"code":"import { load, mapToCanvas, createImage } from './image';\nimport { dataUrl as mapToDataUrl } from './canvas';\nimport { blob as mapToBlob } from './blob';\nimport * as style from './style';\nimport { clone, extend } from './object';\nimport pool from './canvas/pool';\n/**\n * A configuration type for the watermark function\n *\n * @typedef {Object} Options\n * @property {Function} init - an initialization function that is given Image objects before loading (only applies if resources is a collection of urls)\n * @property {ImageFormat} type - specify the image format to be used when retrieving result (only supports \"image/png\" or \"image/jpeg\", default \"image/png\")\n * @property {Number} encoderOptions - specify the image compression quality from 0 to 1 (default 0.92)\n * @property {Number} poolSize - number of canvas elements available for drawing,\n * @property {CanvasPool} pool - the pool used. If provided, poolSize will be ignored\n */\n\n/**\n * @constant\n * @type {Options}\n */\n\nconst defaults = {\n  init: () => {},\n  type: 'image/png',\n  encoderOptions: 0.92\n};\n/**\n * Merge the given options with the defaults\n *\n * @param {Options} options\n * @return {Options}\n */\n\nfunction mergeOptions(options) {\n  return extend(clone(defaults), options);\n}\n/**\n * Release canvases from a draw result for reuse. Returns\n * the dataURL from the result's canvas\n *\n * @param {DrawResult} result\n * @param {CanvasPool} pool\n * @return  {String}\n */\n\n\nfunction release(result, pool, parameters) {\n  const {\n    canvas,\n    sources\n  } = result;\n  const dataURL = mapToDataUrl(canvas, parameters);\n  sources.forEach(pool.release);\n  return dataURL;\n}\n/**\n * Return a watermark object\n *\n *\n * @param {Array} resources - a collection of urls, File objects, or Image objects\n * @param {Options} options - a configuration object for watermark\n * @param {Promise} promise - optional\n * @return {Object}\n */\n\n\nexport default function watermark(resources) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let promise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const opts = mergeOptions(options);\n  promise || (promise = load(resources, opts.init));\n  return {\n    /**\n     * Convert the watermarked image into a dataUrl. The draw\n     * function is given all images as canvas elements in order\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    dataUrl(draw) {\n      const promise = this.then(images => mapToCanvas(images, pool)).then(canvases => style.result(draw, canvases)).then(result => release(result, pool, {\n        type: opts.type,\n        encoderOptions: opts.encoderOptions\n      }));\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Load additional resources\n     *\n     * @param {Array} resources - a collection of urls, File objects, or Image objects\n     * @param {Function} init - an initialization function that is given Image objects before loading (only applies if resources is a collection of urls)\n     * @return {Object}\n     */\n    load(resources, init) {\n      const promise = this.then(resource => load([resource].concat(resources), init));\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Render the current state of the watermarked image. Useful for performing\n     * actions after the watermark has been applied\n     *\n     * @return {Object}\n     */\n    render() {\n      const promise = this.then(resource => load([resource]));\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Convert the watermark into a blob\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    blob(draw) {\n      const promise = this.dataUrl(draw).then(mapToBlob);\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Convert the watermark into an image using the given draw function\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    image(draw) {\n      const promise = this.dataUrl(draw).then(createImage);\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Delegate to the watermark promise\n     *\n     * @return {Promise}\n     */\n    then() {\n      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n        funcs[_key] = arguments[_key];\n      }\n\n      return promise.then.apply(promise, funcs);\n    }\n\n  };\n}\n;\n/**\n * Style functions\n */\n\nwatermark.image = style.image;\nwatermark.text = style.text;\n/**\n * Clean up all canvas references\n */\n\nwatermark.destroy = () => pool.clear();","map":{"version":3,"sources":["/home/danny/apps/sandbox/nifty/node_modules/watermarkjs/lib/index.js"],"names":["load","mapToCanvas","createImage","dataUrl","mapToDataUrl","blob","mapToBlob","style","clone","extend","pool","defaults","init","type","encoderOptions","mergeOptions","options","release","result","parameters","canvas","sources","dataURL","forEach","watermark","resources","promise","opts","draw","then","images","canvases","resource","concat","render","image","funcs","apply","text","destroy","clear"],"mappings":"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","sourcesContent":["import {load, mapToCanvas, createImage} from './image';\nimport {dataUrl as mapToDataUrl} from './canvas';\nimport {blob as mapToBlob} from './blob';\nimport * as style from './style';\nimport {clone, extend} from './object';\nimport pool from './canvas/pool';\n\n/**\n * A configuration type for the watermark function\n *\n * @typedef {Object} Options\n * @property {Function} init - an initialization function that is given Image objects before loading (only applies if resources is a collection of urls)\n * @property {ImageFormat} type - specify the image format to be used when retrieving result (only supports \"image/png\" or \"image/jpeg\", default \"image/png\")\n * @property {Number} encoderOptions - specify the image compression quality from 0 to 1 (default 0.92)\n * @property {Number} poolSize - number of canvas elements available for drawing,\n * @property {CanvasPool} pool - the pool used. If provided, poolSize will be ignored\n */\n\n/**\n * @constant\n * @type {Options}\n */\nconst defaults = {\n  init: () => {},\n  type: 'image/png',\n  encoderOptions: 0.92\n}\n\n/**\n * Merge the given options with the defaults\n *\n * @param {Options} options\n * @return {Options}\n */\nfunction mergeOptions(options) {\n  return extend(clone(defaults), options);\n}\n\n/**\n * Release canvases from a draw result for reuse. Returns\n * the dataURL from the result's canvas\n *\n * @param {DrawResult} result\n * @param {CanvasPool} pool\n * @return  {String}\n */\nfunction release(result, pool, parameters) {\n  const { canvas, sources } = result;\n  const dataURL = mapToDataUrl(canvas, parameters);\n  sources.forEach(pool.release);\n  return dataURL;\n}\n\n/**\n * Return a watermark object\n *\n *\n * @param {Array} resources - a collection of urls, File objects, or Image objects\n * @param {Options} options - a configuration object for watermark\n * @param {Promise} promise - optional\n * @return {Object}\n */\nexport default function watermark(resources, options = {}, promise = null) {\n  const opts = mergeOptions(options);\n  promise || (promise = load(resources, opts.init));\n\n  return {\n    /**\n     * Convert the watermarked image into a dataUrl. The draw\n     * function is given all images as canvas elements in order\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    dataUrl(draw) {\n      const promise = this\n        .then(images => mapToCanvas(images, pool))\n        .then(canvases => style.result(draw, canvases))\n        .then(result => release(result, pool, { type: opts.type, encoderOptions:opts.encoderOptions }));\n\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Load additional resources\n     *\n     * @param {Array} resources - a collection of urls, File objects, or Image objects\n     * @param {Function} init - an initialization function that is given Image objects before loading (only applies if resources is a collection of urls)\n     * @return {Object}\n     */\n    load(resources, init) {\n      const promise = this\n        .then(resource => load([resource].concat(resources), init));\n\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Render the current state of the watermarked image. Useful for performing\n     * actions after the watermark has been applied\n     *\n     * @return {Object}\n     */\n    render() {\n      const promise = this\n        .then(resource => load([resource]));\n\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Convert the watermark into a blob\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    blob(draw) {\n      const promise = this.dataUrl(draw)\n        .then(mapToBlob);\n\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Convert the watermark into an image using the given draw function\n     *\n     * @param {Function} draw\n     * @return {Object}\n     */\n    image(draw) {\n      const promise = this.dataUrl(draw)\n        .then(createImage);\n\n      return watermark(resources, opts, promise);\n    },\n\n    /**\n     * Delegate to the watermark promise\n     *\n     * @return {Promise}\n     */\n    then(...funcs) {\n      return promise.then.apply(promise, funcs);\n    }\n  };\n};\n\n/**\n * Style functions\n */\nwatermark.image = style.image;\nwatermark.text = style.text;\n\n/**\n * Clean up all canvas references\n */\nwatermark.destroy = () => pool.clear();\n"]},"metadata":{},"sourceType":"module"}